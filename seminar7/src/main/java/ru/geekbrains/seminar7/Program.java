package ru.geekbrains.seminar7;

public class Program {

    // Шаблоны проектирования
    // Один шаблон может быть реализован разными способами, в зависимости от языка
    // где-то может быть использован один способ, где-то три
    // как правило существует простая реализация доступная в рамках практически
    // любого языка.
    // Есть специфические шаблоны - для определенных ЯП.

    // Шаблоны имеют свою классификацию: порождающие (наиболее распространенные), структурные, поведенченские.
    // Порождающие шаблоны: цель - создание новых объектов;
    // Структурные: если есть n кол-во объектов, которые были созданы;
    // на базе различных типов (классов) и должны как-то взаимодействовать.
    // Отвечают за построение связей между отдельными объектами приложения (Адаптер, наблюдатель)
    // (Adapter, Observer)

    // Порождающие паттерны
    // Самый известный и простой для понимания порождающий паттерн - Singleton (одиночка)
    // Объект должен существовать в единственном экземпляре, это гарантирует данный паттерн.
    // Справочник должен не изменяться (абсолютно статичен) - можно применять для отработки запросов.
    // Работа приложения с Singleton'ом быстрее, чем постоянно дергать базу данных

    // Второй пораждающий шаблон - Builder
    // Часто используется, когда у объекта огромное кол-во состоянй
    // при этом объект может быть проинициолизирован только с частей состояний
    // (напр. когда есть часть обязательных полей, часть необязательных
    // и вариаций создания объектов большое количество)

    // Третий пораждающий шаблон - Фабричный метод
    // Используется, когда есть множество разных типов, описывающих объекты различных типов,
    // и при этом есть нужда в главное точке (метод в рамках какого-либо модуля),
    // который позволит генерировать объекты на базе разных типов,
    // с предустановленными настройками (напр. с инициализацией определенных полей)
    // Можно при обращении указывать какой объект нужен
    // Есть библоитеки (напр. Faker) в которых заложен данный паттерн,
    // что позволяет создавать много объектов и тестить систему


    // Структурные паттерны
    // Первый - Адаптер
    // Позволяет преобразовывать интерфейс одного класса в
    // интерфейс другого, который ожидает от нас целевой клиент
    // Напр. смс-шлюз, интерфейс нового провайдера подстраиваем под свой целевой интерфейс

    // Второй - Наблюдатель
    // Назначение: наблюдатель определяет связь 1 ко многим
    // между объектами таким образом, что при изменении одного
    // главного объекта, все зависящие оповещаются об этом и обновляют свое состояние или поведение.
    // Publisher - тот кто создает событие
    public static void main(String[] args) {

    }
}
